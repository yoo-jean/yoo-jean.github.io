---
title: JVM 정리 노트 ⑦ GC 알고리즘과 성능 튜닝
date: 2026-01-05 18:00:00 +0900
categories: [CS, JVM]
tags: [jvm, java, runtime, gc, memory]
---

GC 성능을 이해하기 위해서는  
먼저 **GC가 메모리를 어떻게 정리하는지(알고리즘)** 를 알아야 한다.  
튜닝은 그 다음 단계이다.

---

## GC 알고리즘 개요

GC는 기본적으로 다음 세 가지 알고리즘을 조합하여 동작한다.

### ① Mark & Sweep
- **Mark**
  - GC Root에서 시작하여 참조 중인 객체를 마킹
- **Sweep**
  - 마킹되지 않은 객체를 제거

**특징**
- 구현이 단순
- 메모리 단편화(Fragmentation) 발생 가능
- Old Generation에서 주로 사용

---

### ② Copying
- 살아있는 객체만 다른 영역으로 복사
- 기존 영역은 한 번에 정리

**특징**
- 단편화 문제 없음
- 살아있는 객체 수가 적을수록 효율적
- Young Generation(Survivor 영역)에서 주로 사용

---

### ③ Compact
- 살아있는 객체를 한쪽으로 모아 정렬
- 연속된 메모리 공간 확보

**특징**
- 단편화 제거
- 객체 이동 비용 발생
- Major GC / Full GC 과정에서 사용

---

## GC 로그 보는 법 (기본)

GC 튜닝의 출발점은 **GC 로그 분석**이다.  
로그 없이 튜닝은 거의 의미가 없다.

### 자주 확인하는 정보
- GC 발생 시점
- GC 종류 (Minor / Major / Full)
- GC 소요 시간
- Heap 사용량 변화

### 대표적인 로그 옵션
```
-Xlog:gc
```

로그 예시에서 확인할 포인트:
- GC 빈도가 과도하지 않은지
- STW 시간이 비정상적으로 긴지
- Old Generation이 급격히 증가하는지

---

## Heap 크기 옵션 의미

### `-Xms` (Initial Heap Size)
- JVM 시작 시 Heap의 초기 크기
- 너무 작으면 초기 GC가 잦아질 수 있음

### `-Xmx` (Max Heap Size)
- Heap의 최대 크기
- 이 값을 초과하면 `OutOfMemoryError` 발생

### 일반적인 권장 사항
- `-Xms`와 `-Xmx`를 동일하게 설정
  - Heap 확장/축소 비용 제거
  - GC 패턴 안정화

---

## GC 튜닝 시 주의사항

> **GC 튜닝은 최후의 수단이다.**

대부분의 성능 문제는 GC 자체보다  
다음과 같은 원인에서 시작된다.

- 객체 생명주기 설계 미흡
- 불필요한 객체 반복 생성
- 캐시 전략 부재
- 컬렉션 사용 방식 문제

GC 튜닝은 이러한 문제를 해결한 뒤,  
**마지막 단계에서 수행하는 보완 작업**이다.

---

## 정리

- GC 알고리즘은 목적에 따라 조합되어 사용됨
- 로그 분석 없이 튜닝은 위험
- Heap 옵션은 GC 패턴에 직접적인 영향
- 근본적인 성능 개선은 **객체 생성 패턴 개선**에서 시작

---

> 좋은 GC 튜닝은  
> 옵션을 바꾸는 것이 아니라  
> **객체를 어떻게 생성하고 사용하는지 이해하는 것**에서 출발한다.
