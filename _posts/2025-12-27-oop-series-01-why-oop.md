---
title: 객체지향, 다시 생각하다 ① 왜 객체지향이 중요한가
date: 2025-12-27 00:30:00 +0900
categories: [CS, OOP]
tags: [oop, object-oriented, solid, design]
---

## 개요
객체지향 프로그래밍(OOP)은 단순히 문법이나 코드 스타일의 문제가 아니라,  
**변경에 강한 소프트웨어를 만들기 위한 설계 방법론**이라고 생각한다.

이 글에서는 객체지향의 핵심 개념을 정리하고,  
실제 개발에서 왜 객체지향이 계속해서 중요하게 언급되는지에 대해  
나름의 기준으로 정리해보고자 한다.

---

## 왜 객체지향이 필요해졌을까
소프트웨어의 규모가 커질수록 요구사항 변경은 피할 수 없고,  
그 변경은 항상 기존 코드에 영향을 준다.

절차지향 방식에서는
- 데이터와 로직이 분리되어 있고
- 변경 규칙이 여러 곳에 흩어지기 쉬워

작은 수정 하나가  
예상하지 못한 버그로 이어지는 경우가 많다.

객체지향은 이러한 문제를  
**“변경이 발생하는 지점을 객체의 책임 안으로 모으는 방식”** 으로  
해결하려는 시도라고 생각한다.

---

## 객체지향이란 무엇인가
객체지향은 **데이터와 그 데이터를 처리하는 행위를 하나의 객체로 묶고**,  
객체 간의 협력을 통해 시스템을 구성하는 방식이다.

중요한 점은 “어떻게 구현했는가”보다  
**“객체가 어떤 책임을 가지고 있는가”** 에 초점을 둔다는 것이다.

---

## 객체지향의 4가지 핵심 원리

### 1. 캡슐화 (Encapsulation)
객체 내부의 상태를 외부에서 직접 변경하지 못하도록 숨기고,  
정해진 메서드를 통해서만 접근하도록 제한하는 원리이다.

캡슐화를 통해:
- 객체의 내부 구현 변경이 외부에 영향을 주지 않도록 하고
- 잘못된 상태 변경을 방지할 수 있다.

```java
public class Account {
    private long balance;

    public void deposit(long amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException();
        }
        balance += amount;
    }
}
```

### 2. 추상화 (Abstraction)
복잡한 구현 세부 사항은 감추고, 객체가 수행하는 핵심 역할만 외부에 드러내는 것이다.

추상화를 통해:
- 구현 교체가 쉬워지고
- 테스트와 확장이 용이해진다.

```java
public interface PaymentService {
  void pay(long amount);
}
```

### 3. 상속 (Inheritance)
기존 클래스의 기능을 재사용하여 새로운 클래스를 만드는 기법이다.

다만 상속은:
- 부모 클래스에 강하게 의존하게 되고
- 변경에 취약해질 수 있기 때문에

실무에서는 **무분별한 상속보다 조합(Composition)** 을 선호하는 경우가 많다.

### 4. 다형성 (Polymorphism)
같은 메시지(메서드 호출)라도 객체의 타입에 따라 서로 다른 동작을 수행하는 성질이다.

다형성을 활용하면:
- 조건문(if/else)을 줄일 수 있고
- 기능 확장이 쉬워진다.

```java
public interface DiscountPolicy {
  long discount(long price);
}
```

---

## SOLID 원칙 간단 정리

객체지향 설계를 더 잘하기 위한 대표적인 설계 원칙이다.
- SRP: 하나의 클래스는 하나의 책임만 가진다.
- OCP: 확장에는 열려 있고 변경에는 닫혀 있다.
- LSP: 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.
- ISP: 인터페이스는 작게 분리한다.
- DIP: 구체 클래스가 아닌 추상에 의존한다.

이 원칙들은
객체지향의 개념을 실무에 적용할 때
방향을 잡아주는 가이드 역할을 한다.


---

## 객체지향을 공부하며 느낀 점
처음에는 객체지향을
“상속을 잘 쓰는 방법” 정도로 이해했지만,   
실제로는 **책임을 어떻게 나누고, 변경을 어떻게 흡수할 것인가**에 대한 고민이라는 것을 느꼈다.

결국 객체지향의 목적은
더 복잡한 코드를 만드는 것이 아니라,  
**변경하기 쉬운 코드를 만드는 것**이라고 생각한다.

---

## 마치며
객체지향 원리는 한 번에 완전히 이해하기 어렵고,  
여러 프로젝트를 거치며 계속 다시 보게 되는 개념이라고 느낀다.

앞으로도 실무와 공부를 병행하며  
객체지향 원리를 코드로 어떻게 녹여낼 수 있을지  
지속적으로 정리해볼 예정이다.
