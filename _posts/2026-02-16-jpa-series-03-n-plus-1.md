---
title: JPA 핵심 개념 정리 ③ N+1 문제
date: 2026-02-16 20:00:00 +0900
categories: [CS, JPA]
tags: [JPA, Hibernate, N+1, FetchJoin, EntityGraph, BatchSize, 성능최적화]
---

연관 엔티티 조회 시, **초기 조회 쿼리 1번 + 연관 엔티티 조회 쿼리 N번이
추가로 발생하는 문제**이다.

------------------------------------------------------------------------

## 1. 발생 원인

-   JPA는 연관관계를 기본적으로 LAZY로 조회한다.
-   메인 엔티티 조회 후, 연관 객체에 접근하는 순간 추가 쿼리가 실행된다.
-   반복문 안에서 연관 객체 접근 시 N번 실행된다.

------------------------------------------------------------------------

## 2. 발생 구조

1.  메인 엔티티 조회
2.  반복문에서 연관 엔티티 접근
3.  연관 엔티티 개별 조회 반복

### 예시 코드

``` java
List<Member> members = memberRepository.findAll();

for (Member member : members) {
    System.out.println(member.getTeam().getName());
}
```

### 실행 쿼리

``` sql
SELECT * FROM member;
SELECT * FROM team WHERE id=?;
SELECT * FROM team WHERE id=?;
SELECT * FROM team WHERE id=?;
```

회원이 100명이면 팀 조회 쿼리도 100번 실행된다.

------------------------------------------------------------------------

## 3. 왜 문제인가?

-   네트워크 I/O 증가
-   DB 부하 증가
-   응답 속도 급격히 저하
-   대용량 데이터에서 성능 폭발

운영 환경에서 데이터가 늘어나면 갑자기 느려지는 대표 원인이다.

------------------------------------------------------------------------

# 4. 해결 방법

## ① Fetch Join

``` jpql
SELECT m FROM Member m JOIN FETCH m.team
```

실행 쿼리:

``` sql
SELECT m.*, t.*
FROM member m
JOIN team t ON m.team_id = t.id;
```

-   한 번의 쿼리로 조회
-   상세 조회에 적합
-   컬렉션 fetch join + 페이징 불가

------------------------------------------------------------------------

## ② EntityGraph

``` java
@EntityGraph(attributePaths = "team")
List<Member> findAll();
```

-   JPQL 수정 없이 fetch 전략 제어 가능
-   유지보수에 유리

------------------------------------------------------------------------

## ③ Batch Size

``` java
@BatchSize(size = 100)
```

실행 방식:

``` sql
SELECT * FROM team WHERE id IN (1,2,3,4,5,...);
```

-   LAZY 유지하면서 묶어서 조회
-   페이징과 함께 사용 가능
-   목록 조회에 적합

------------------------------------------------------------------------

## ④ 글로벌 설정

``` yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

-   모든 LAZY 연관관계에 일괄 적용
-   실무에서 기본 세팅으로 자주 사용

------------------------------------------------------------------------

# 5. Fetch Join vs Batch Size 비교

구분          Fetch Join         Batch Size
  ------------- ------------------ -------------------
쿼리 수       1번                1 + 1
페이징        ❌ 컬렉션은 불가   가능
메모리 사용   많을 수 있음       상대적으로 안정적
사용 시점     상세 조회          목록 조회

------------------------------------------------------------------------

# 6. 주의할 점

## 6-1. EAGER로 해결하려 하지 말 것

``` java
@ManyToOne(fetch = FetchType.EAGER)
```

-   항상 조인 발생
-   예상치 못한 쿼리 폭증 가능
-   실무에서는 지양

------------------------------------------------------------------------

## 6-2. 컬렉션 Fetch Join + 페이징 금지

``` jpql
SELECT t FROM Team t JOIN FETCH t.members
```

-   중복 row 발생
-   limit 적용 불가
-   메모리 문제 발생

해결 패턴:

1.  ID만 페이징 조회
2.  IN 절로 상세 재조회

------------------------------------------------------------------------

# 7. 면접 한 줄 정리

> N+1 문제는 연관 엔티티 조회 시 추가 쿼리가 반복 실행되는 문제이며,\
> Fetch Join, EntityGraph, Batch Size 등을 통해 상황에 맞게 해결합니다.\
> 목록 조회에서는 Batch Size, 상세 조회에서는 Fetch Join을 사용합니다.
