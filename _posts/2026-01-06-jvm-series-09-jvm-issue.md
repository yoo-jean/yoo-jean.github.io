---
title: JVM 정리 노트 ⑨ 실무에서 만나는 JVM 이슈들
date: 2026-01-06 17:00:00 +0900
categories: [CS, JVM]
tags: [jvm, java, runtime, gc, memory]
---

JVM 성능 이슈는 대부분 **증상(에러/지연) → 원인(메모리/스레드/GC/코드) → 증거(로그/덤프) → 대응** 순서로 접근해야   
빠르게 해결할 수 있다.  

이 글에서는 실무에서 자주 만나는 대표 이슈들을 **케이스별로** 정리한다.

---

## 1) OutOfMemoryError (OOM) 종류와 진단 포인트

`OutOfMemoryError`는 “메모리가 부족하다”는 단일 의미가 아니라, **어느 메모리 영역이 부족한지**에 따라 원인과 대응이 달라진다.

### 1-1. `java.lang.OutOfMemoryError: Java heap space`
**의미**
- Heap(객체/배열) 영역이 부족
- 객체가 너무 많이 생성되었거나, 해제되지 않고 쌓였거나, Heap 설정이 너무 작을 때 발생

**자주 발생하는 원인**
- 무제한으로 커지는 컬렉션(List/Map/Cache)
- 요청 단위로 큰 객체를 생성하고 오래 들고 있는 구조
- 대용량 결과를 한 번에 메모리에 올리는 로직(예: 대량 조회 후 가공)
- 미해제 참조(메모리 릭): static 컬렉션, 전역 캐시, Listener 등록 누락 등

**즉시 확인할 것**
- OOM 시점 전후 GC 로그에서 Old Gen이 계속 증가했는지
- 최근 배포/트래픽 변화/특정 기능 실행 여부
- Heap dump 확보 가능 여부

**대응**
- Heap dump로 “무엇이 점유하는지” 확인 (아래 덤프 섹션 참고)
- 무제한 캐시/컬렉션 상한 적용, 스트리밍 처리로 전환, 페이징 적용
- `-Xmx` 상향은 임시 대응일 뿐, 원인 제거가 최우선

---

### 1-2. `java.lang.OutOfMemoryError: Metaspace`
**의미**
- 클래스 메타데이터 영역(Metaspace)이 부족
- Java 8 이후 PermGen 대신 Metaspace 사용(네이티브 메모리)

**자주 발생하는 원인**
- 동적 클래스 생성 프레임워크(프록시/바이트코드 생성) 남발
- 핫리로드/재배포 과정에서 ClassLoader 누수(ClassLoader leak)
- 많은 수의 클래스를 로딩하는 구조 + 해제되지 않는 로더

**즉시 확인할 것**
- 재배포/컨테이너 환경에서 ClassLoader가 계속 쌓이는지
- GC 로그에서 Metaspace가 지속 증가하는지
- 동일 앱을 오래 돌릴수록 메모리가 증가하는지

**대응**
- ClassLoader 누수 의심 시: 배포/리로드 방식 점검, 라이브러리/에이전트 확인
- 필요시 Metaspace 상한 설정:
  - `-XX:MaxMetaspaceSize=...`
- 근본적으로는 “왜 클래스가 계속 증가하는지” 원인을 제거

---

### 1-3. `java.lang.OutOfMemoryError: GC overhead limit exceeded`
**의미**
- GC가 너무 자주 돌지만 메모리를 거의 회수하지 못하는 상태
- JVM이 “GC만 하다 끝날 것 같다”고 판단하여 강제 종료

**자주 발생하는 원인**
- Old Gen이 대부분 살아있는 객체로 가득 차 있음(사실상 릭 또는 과도한 유지)
- Heap이 너무 작거나, 객체 생성 패턴이 비효율적

**대응**
- “Heap 부족”과 동일하게 접근하되, 특히 **무한히 살아있는 객체**를 찾는 것이 핵심
- Heap dump 분석 + 불필요 객체 생성/유지 제거

---

### 1-4. `java.lang.OutOfMemoryError: Unable to create new native thread`
**의미**
- 스레드를 더 만들 수 없음 (OS 자원 부족)
- Heap이 아니라 **네이티브 스레드** 생성 실패

**자주 발생하는 원인**
- 요청마다 Thread를 새로 만드는 구조
- Thread pool 설정 과다, 혹은 풀 누수(종료되지 않음)
- OS의 프로세스/스레드 제한(ulimit) 또는 메모리 부족

**즉시 확인할 것**
- 스레드 수가 비정상적으로 증가했는지
- 풀 설정(코어/맥스/큐)과 실제 트래픽 패턴
- OS 제한(ulimit, PID limit 등)

**대응**
- Thread 생성 대신 Executor 기반 풀 사용, 상한 설정
- 요청 폭주 시 큐/백프레셔(backpressure) 적용
- 컨테이너/OS 제한값 점검

---

## 2) StackOverflowError

### 2-1. `java.lang.StackOverflowError`의 의미
- 한 스레드의 Stack이 꽉 차서 더 이상 호출 프레임을 쌓을 수 없음
- 보통 **무한 재귀** 혹은 과도하게 깊은 호출이 원인

**자주 발생하는 원인**
- 종료 조건 없는 재귀
- JSON 직렬화/역직렬화에서 순환 참조(양방향 연관관계)
- 잘못된 프록시/인터셉터 체인으로 인한 반복 호출

**대응**
- 스택트레이스에서 반복되는 메서드 패턴 확인
- 재귀 종료 조건 보강, 순환 참조 제거(DTO 분리, @JsonIgnore 등)
- 임시로 `-Xss`(스레드 스택 크기) 조절은 가능하나 근본 해결이 우선

---

## 3) 메모리 릭(Memory Leak) 실전 사례

“GC가 안 하는 것”이 아니라, 대부분은 **참조가 끊기지 않아 GC 대상이 아닌 것**이 릭이다.

### 3-1. 전역(static) 컬렉션에 계속 쌓이는 데이터
- 예: static Map에 사용자별 데이터 저장 후 제거 안 함
- 해결: 상한/TTL 적용, 캐시 라이브러리 사용(Caffeine 등), 제거 로직 명확화

### 3-2. 캐시 무제한 사용
- 캐시 히트율만 보고 무제한으로 두면 Old Gen을 고정 점유
- 해결: 최대 크기(max size), 만료 정책(expire), 통계 기반 튜닝

### 3-3. Listener/Callback 등록 후 해제 누락
- 이벤트 리스너가 객체를 참조하며 생명주기를 연장
- 해결: 등록/해제 짝 맞추기, 약한 참조(WeakReference) 고려

### 3-4. ThreadLocal 미정리
- 스레드 풀 환경에서 ThreadLocal을 제거하지 않으면 값이 오래 살아남음
- 해결: 사용 후 `remove()` 호출, 요청 스코프 관리

### 3-5. ClassLoader Leak (특히 WAS/컨테이너)
- 리로드/재배포 후에도 이전 ClassLoader가 해제되지 않아 Metaspace 증가
- 해결: 리로드 방식/에이전트/라이브러리 점검, 컨테이너 설정 확인

---

## 4) “느려짐” 케이스: GC, 스레드, 락, IO

성능 저하는 대개 4가지 축으로 나뉜다.

### 4-1. GC로 인한 지연 (STW)
**증상**
- 특정 구간에서 응답이 ‘툭’ 끊김
- Latency가 주기적으로 튀는 패턴

**확인 방법**
- GC 로그에서 Pause Time 확인
- Full GC 발생 여부, Old Gen 점유율

**대응**
- 불필요 객체 생성 줄이기(가장 효과 큼)
- 힙 사이즈/Young 비율/GC 종류(G1 등) 점검
- 대용량 처리 로직은 스트리밍/배치 분리

### 4-2. 스레드 풀 고갈(Thread pool exhaustion)
**증상**
- 요청 대기 증가, 타임아웃 증가
- CPU는 낮은데 요청은 밀림

**확인 방법**
- 스레드 덤프에서 RUNNABLE보다 WAITING/BLOCKED가 많은지
- 풀 큐 길이/거절 정책(rejection) 동작 여부

**대응**
- 풀 크기 조절보다 먼저 “왜 막히는지” 확인(IO, 락, 외부 연동)
- 타임아웃/서킷브레이커 등 방어 로직 적용

### 4-3. 락 경합(Lock contention)
**증상**
- CPU는 있는데 처리량이 안 나옴 / BLOCKED 스레드 증가

**확인 방법**
- Thread dump에서 동일 락을 기다리는 스레드 다수 확인

**대응**
- 임계영역 축소, 자료구조 변경(Concurrent 컬렉션), 락 분리(striping)

### 4-4. 외부 IO 병목(DB/HTTP/파일)
**증상**
- 응답이 느려지고 타임아웃 증가
- 스레드 덤프에서 IO 대기(WAITING) 다수

**대응**
- 타임아웃/재시도 정책 점검
- 커넥션 풀/쿼리 튜닝/호출량 제한

---

## 5) Heap Dump / Thread Dump 실무 활용

### 5-1. Heap Dump (무엇이 메모리를 먹는지)
**목적**
- “가장 많이 점유하는 객체는 무엇인가?”를 찾는다.

**언제 뜨나**
- OOM 직후 혹은 의심 시점에 수동으로 뜸

**자주 보는 항목**
- Dominator Tree(누가 누구를 붙잡고 있는지)
- Top Consumers(가장 많이 점유하는 타입)
- Retained Size(해제될 수 있는 메모리 규모)

**실무 팁**
- “큰 객체”보다 “많이 쌓인 객체”가 더 위험한 경우가 많다.
- 캐시/컬렉션/세션/DTO 등이 상위에 자주 등장한다.

### 5-2. Thread Dump (무엇이 스레드를 막는지)
**목적**
- “지금 왜 멈춰있나? 무엇을 기다리나?”를 찾는다.

**자주 보는 상태**
- RUNNABLE: CPU 작업 중
- BLOCKED: 락 대기
- WAITING/TIMED_WAITING: 조건/IO/대기

**실무 팁**
- 특정 락/메서드가 반복해서 등장하면 병목 가능성이 높다.
- 외부 호출(HTTP/DB)이 많으면 타임아웃/풀 고갈로 이어지기 쉽다.

---

## 6) 빠르게 원인 좁히는 체크리스트

- [ ] 에러 종류(OOM/StackOverflow)와 메시지 정확히 확인
- [ ] GC 로그에서 STW/Full GC/Old Gen 증가 확인
- [ ] 스레드 수/스레드 풀 상태 확인
- [ ] Heap dump / Thread dump 확보 가능 여부 확인
- [ ] “최근 변경”과 “특정 트래픽 패턴” 매칭
- [ ] 임시 대응(증설/옵션 변경)과 근본 해결(코드/설계 개선) 분리

---

> 실무에서 중요한 건 “옵션을 바꾸는 스킬”보다  
> **증상 → 근거 → 원인 → 해결**로 좁혀가는 분석 순서다.
