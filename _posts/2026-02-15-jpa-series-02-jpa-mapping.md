---
title: JPA 핵심 개념 정리 ② 연관관계
date: 20202-15 20:00:00 +0900
categories: [CS, JPA]
tags: [JPA, Hibernate, 연관관계, OneToMany, ManyToOne, 영속성컨텍스트]
---

연관관계 매핑은 **객체 간 관계를 DB 테이블 관계로 매핑하는 기능**이다.\
객체는 참조(Reference)를 사용하고, DB는 외래키(Foreign Key)를 사용한다.

JPA는 이 차이를 연결해주는 ORM 매핑 기술이다.

------------------------------------------------------------------------

## 1. 연관관계 종류


|관계  | 어노테이션   | 설명|
 | ------ |-------------| -------------|
|1:N  |  @OneToMany   | 부모 → 자식|
|N:1   | @ManyToOne   | 자식 → 부모|
|1:1   | @OneToOne    | 1:1 관계|
|N:M  |  @ManyToMany |  다대다 관계|

###  실무 원칙

-   실무에서는 **N:M을 직접 사용하지 않는다**
-   중간 테이블을 엔티티로 승격시켜 1:N + N:1 구조로 풀어낸다

``` java
@Entity
class MemberTeam {

    @ManyToOne
    @JoinColumn(name = "member_id")
    private Member member;

    @ManyToOne
    @JoinColumn(name = "team_id")
    private Team team;
}
```

이렇게 하면 추가 컬럼(가입일, 권한 등)을 유연하게 확장할 수 있다.

------------------------------------------------------------------------

# 2. 연관관계의 주인

외래키를 관리하는 쪽이 연관관계의 주인이다.

-   `mappedBy`가 없는 쪽이 주인
-   DB UPDATE는 오직 주인만 수행한다

``` java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "team_id")
private Team team;
```

### 왜 중요할까?

-   주인이 아닌 쪽에서 값 변경해도 DB 반영되지 않는다
-   실무에서 "왜 UPDATE 안 되지?" 문제의 대표 원인

------------------------------------------------------------------------

# 3. 양방향 매핑 주의점

양방향은 객체 그래프 탐색이 편리하지만, 관리 포인트가 늘어난다.

### ✔ 연관관계 편의 메서드 필수

``` java
public void changeTeam(Team team){
    this.team = team;
    team.getMembers().add(this);
}
```

### ✔ 컬렉션 초기화 필수

``` java
@OneToMany(mappedBy = "team")
private List<Member> members = new ArrayList<>();
```

초기화하지 않으면 NullPointerException 발생 가능.

------------------------------------------------------------------------

# 4. 연관관계 설계 원칙

## ① 단방향 우선 설계

-   처음부터 양방향으로 설계하지 말 것
-   정말 필요한 경우에만 추가

## ② ManyToOne은 기본 LAZY

``` java
@ManyToOne(fetch = FetchType.LAZY)
```

EAGER는 예측 불가능한 조인 발생 → 성능 저하 원인

## ③ OneToMany는 거의 조회용

-   실제 DB 외래키는 ManyToOne 쪽에 존재
-   OneToMany는 읽기 편의 목적

------------------------------------------------------------------------

# 5. 연관관계 문제점

## 5-1. 무한 참조 문제

양방향 + JSON 직렬화 시 StackOverflow 발생

### 해결 방법

-   DTO 변환
-   @JsonIgnore 사용
-   단방향 설계

------------------------------------------------------------------------

## 5-2. N+1 문제

연관 엔티티 접근 시 추가 쿼리 반복 발생

### 해결 방법

-   Fetch Join
-   EntityGraph
-   Batch Size

------------------------------------------------------------------------

## 5-3. LazyInitializationException

트랜잭션 종료 후 LAZY 필드 접근 시 발생

### 원인

-   영속성 컨텍스트 종료
-   OSIV 비활성화 환경

### 해결 방법

-   트랜잭션 내부에서 DTO 변환
-   필요한 데이터는 미리 fetch

------------------------------------------------------------------------

## 5-4. Cascade 오남용

``` java
@OneToMany(cascade = CascadeType.ALL)
```

무분별한 ALL 사용은 예기치 않은 삭제/전파 발생

### 실무 기준

-   생명주기가 완전히 동일한 경우만 cascade 사용

------------------------------------------------------------------------

## 5-5. 성능 저하

-   불필요한 조인
-   대량 컬렉션 fetch join
-   잘못된 페이징

------------------------------------------------------------------------

# 6. 실무 설계 정리

✔ 단방향 우선\
✔ ManyToOne LAZY 기본\
✔ 연관관계 주인 명확히 이해\
✔ DTO 기반 반환\
✔ N+1 방지 전략 적용

------------------------------------------------------------------------

# 7. 면접 한 줄 정리

> 연관관계 매핑은 객체 참조와 외래키를 연결하는 ORM 기능이며,\
> 연관관계의 주인 개념과 LAZY 전략, N+1 문제를 이해하는 것이 핵심입니다.
